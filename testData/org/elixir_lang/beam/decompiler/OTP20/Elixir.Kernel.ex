# Source code recreated from a .beam file by IntelliJ Elixir
defmodule Kernel do

  # Macros

  defmacro unquote(:!)(p0) do
    # body not decompiled
  end

  defmacro left && right do
    # body not decompiled
  end

  defmacro left .. right do
    # body not decompiled
  end

  defmacro left <> right do
    # body not decompiled
  end

  defmacro unquote(:@)(p0) do
    # body not decompiled
  end

  defmacro alias!(p0) do
    # body not decompiled
  end

  defmacro left and right do
    # body not decompiled
  end

  defmacro binding() do
    # body not decompiled
  end

  defmacro binding(p0) do
    # body not decompiled
  end

  defmacro def(p0) do
    # body not decompiled
  end

  defmacro def(p0, p1) do
    # body not decompiled
  end

  defmacro defdelegate(p0, p1) do
    # body not decompiled
  end

  defmacro defexception(p0) do
    # body not decompiled
  end

  defmacro defimpl(p0, p1) do
    # body not decompiled
  end

  defmacro defimpl(p0, p1, p2) do
    # body not decompiled
  end

  defmacro defmacro(p0) do
    # body not decompiled
  end

  defmacro defmacro(p0, p1) do
    # body not decompiled
  end

  defmacro defmacrop(p0) do
    # body not decompiled
  end

  defmacro defmacrop(p0, p1) do
    # body not decompiled
  end

  defmacro defmodule(p0, p1) do
    # body not decompiled
  end

  defmacro defoverridable(p0) do
    # body not decompiled
  end

  defmacro defp(p0) do
    # body not decompiled
  end

  defmacro defp(p0, p1) do
    # body not decompiled
  end

  defmacro defprotocol(p0, p1) do
    # body not decompiled
  end

  defmacro defstruct(p0) do
    # body not decompiled
  end

  defmacro destructure(p0, p1) do
    # body not decompiled
  end

  defmacro get_and_update_in(p0, p1) do
    # body not decompiled
  end

  defmacro if(p0, p1) do
    # body not decompiled
  end

  defmacro left in right do
    # body not decompiled
  end

  defmacro is_nil(p0) do
    # body not decompiled
  end

  defmacro match?(p0, p1) do
    # body not decompiled
  end

  defmacro left or right do
    # body not decompiled
  end

  defmacro pop_in(p0) do
    # body not decompiled
  end

  defmacro put_in(p0, p1) do
    # body not decompiled
  end

  defmacro raise(p0) do
    # body not decompiled
  end

  defmacro raise(p0, p1) do
    # body not decompiled
  end

  defmacro reraise(p0, p1) do
    # body not decompiled
  end

  defmacro reraise(p0, p1, p2) do
    # body not decompiled
  end

  defmacro sigil_C(p0, p1) do
    # body not decompiled
  end

  defmacro sigil_D(p0, p1) do
    # body not decompiled
  end

  defmacro sigil_N(p0, p1) do
    # body not decompiled
  end

  defmacro sigil_R(p0, p1) do
    # body not decompiled
  end

  defmacro sigil_S(p0, p1) do
    # body not decompiled
  end

  defmacro sigil_T(p0, p1) do
    # body not decompiled
  end

  defmacro sigil_W(p0, p1) do
    # body not decompiled
  end

  defmacro sigil_c(p0, p1) do
    # body not decompiled
  end

  defmacro sigil_r(p0, p1) do
    # body not decompiled
  end

  defmacro sigil_s(p0, p1) do
    # body not decompiled
  end

  defmacro sigil_w(p0, p1) do
    # body not decompiled
  end

  defmacro to_char_list(p0) do
    # body not decompiled
  end

  defmacro to_charlist(p0) do
    # body not decompiled
  end

  defmacro to_string(p0) do
    # body not decompiled
  end

  defmacro unless(p0, p1) do
    # body not decompiled
  end

  defmacro update_in(p0, p1) do
    # body not decompiled
  end

  defmacro use(p0) do
    # body not decompiled
  end

  defmacro use(p0, p1) do
    # body not decompiled
  end

  defmacro var!(p0) do
    # body not decompiled
  end

  defmacro var!(p0, p1) do
    # body not decompiled
  end

  defmacro left |> right do
    # body not decompiled
  end

  defmacro left || right do
    # body not decompiled
  end

  # Functions

  def left != right do
    # body not decompiled
  end

  def left !== right do
    # body not decompiled
  end

  def left * right do
    # body not decompiled
  end

  def (+value) do
    # body not decompiled
  end

  def left + right do
    # body not decompiled
  end

  def left ++ right do
    # body not decompiled
  end

  def (-value) do
    # body not decompiled
  end

  def left - right do
    # body not decompiled
  end

  def left -- right do
    # body not decompiled
  end

  def left / right do
    # body not decompiled
  end

  def left < right do
    # body not decompiled
  end

  def left <= right do
    # body not decompiled
  end

  def left == right do
    # body not decompiled
  end

  def left === right do
    # body not decompiled
  end

  def left =~ right do
    # body not decompiled
  end

  def left > right do
    # body not decompiled
  end

  def left >= right do
    # body not decompiled
  end

  def __info__(p0) do
    # body not decompiled
  end

  def abs(p0) do
    # body not decompiled
  end

  def apply(p0, p1) do
    # body not decompiled
  end

  def apply(p0, p1, p2) do
    # body not decompiled
  end

  def binary_part(p0, p1, p2) do
    # body not decompiled
  end

  def bit_size(p0) do
    # body not decompiled
  end

  def byte_size(p0) do
    # body not decompiled
  end

  def div(p0, p1) do
    # body not decompiled
  end

  def elem(p0, p1) do
    # body not decompiled
  end

  def exit(p0) do
    # body not decompiled
  end

  def function_exported?(p0, p1, p2) do
    # body not decompiled
  end

  def get_and_update_in(p0, p1, p2) do
    # body not decompiled
  end

  def get_in(p0, p1) do
    # body not decompiled
  end

  def hd(p0) do
    # body not decompiled
  end

  def inspect(p0) do
    # body not decompiled
  end

  def inspect(p0, p1) do
    # body not decompiled
  end

  def is_atom(p0) do
    # body not decompiled
  end

  def is_binary(p0) do
    # body not decompiled
  end

  def is_bitstring(p0) do
    # body not decompiled
  end

  def is_boolean(p0) do
    # body not decompiled
  end

  def is_float(p0) do
    # body not decompiled
  end

  def is_function(p0) do
    # body not decompiled
  end

  def is_function(p0, p1) do
    # body not decompiled
  end

  def is_integer(p0) do
    # body not decompiled
  end

  def is_list(p0) do
    # body not decompiled
  end

  def is_map(p0) do
    # body not decompiled
  end

  def is_number(p0) do
    # body not decompiled
  end

  def is_pid(p0) do
    # body not decompiled
  end

  def is_port(p0) do
    # body not decompiled
  end

  def is_reference(p0) do
    # body not decompiled
  end

  def is_tuple(p0) do
    # body not decompiled
  end

  def length(p0) do
    # body not decompiled
  end

  def macro_exported?(p0, p1, p2) do
    # body not decompiled
  end

  def make_ref() do
    # body not decompiled
  end

  def map_size(p0) do
    # body not decompiled
  end

  def max(p0, p1) do
    # body not decompiled
  end

  def min(p0, p1) do
    # body not decompiled
  end

  def module_info() do
    # body not decompiled
  end

  def module_info(p0) do
    # body not decompiled
  end

  def node() do
    # body not decompiled
  end

  def node(p0) do
    # body not decompiled
  end

  def not(p0) do
    # body not decompiled
  end

  def pop_in(p0, p1) do
    # body not decompiled
  end

  def put_elem(p0, p1, p2) do
    # body not decompiled
  end

  def put_in(p0, p1, p2) do
    # body not decompiled
  end

  def rem(p0, p1) do
    # body not decompiled
  end

  def round(p0) do
    # body not decompiled
  end

  def self() do
    # body not decompiled
  end

  def send(p0, p1) do
    # body not decompiled
  end

  def spawn(p0) do
    # body not decompiled
  end

  def spawn(p0, p1, p2) do
    # body not decompiled
  end

  def spawn_link(p0) do
    # body not decompiled
  end

  def spawn_link(p0, p1, p2) do
    # body not decompiled
  end

  def spawn_monitor(p0) do
    # body not decompiled
  end

  def spawn_monitor(p0, p1, p2) do
    # body not decompiled
  end

  def struct(p0) do
    # body not decompiled
  end

  def struct(p0, p1) do
    # body not decompiled
  end

  def struct!(p0) do
    # body not decompiled
  end

  def struct!(p0, p1) do
    # body not decompiled
  end

  def throw(p0) do
    # body not decompiled
  end

  def tl(p0) do
    # body not decompiled
  end

  def trunc(p0) do
    # body not decompiled
  end

  def tuple_size(p0) do
    # body not decompiled
  end

  def update_in(p0, p1, p2) do
    # body not decompiled
  end

  # Private Functions

  defp unquote(:"-MACRO-binding/2-fun-0-")(p0, p1, p2, p3) do
    # body not decompiled
  end

  defp unquote(:"-MACRO-in/3-fun-0-")(p0, p1, p2) do
    # body not decompiled
  end

  defp unquote(:"-MACRO-in/3-fun-1-")(p0, p1, p2) do
    # body not decompiled
  end

  defp unquote(:"-MACRO-sigil_r/3-fun-0-")(p0) do
    # body not decompiled
  end

  defp unquote(:"-MACRO-sigil_r/3-fun-1-")(p0) do
    # body not decompiled
  end

  defp unquote(:"-MACRO-use/3-fun-0-")(p0, p1, p2) do
    # body not decompiled
  end

  defp unquote(:"-MACRO-|>/3-fun-0-")(p0, p1, p2) do
    # body not decompiled
  end

  defp unquote(:"-do_pop_in/2-fun-0-")(p0) do
    # body not decompiled
  end

  defp unquote(:"-do_pop_in/2-fun-1-")(p0, p1) do
    # body not decompiled
  end

  defp unquote(:"-do_pop_in/2-fun-2-")(p0, p1) do
    # body not decompiled
  end

  defp unquote(:"-expand_aliases/2-fun-0-")(p0, p1) do
    # body not decompiled
  end

  defp unquote(:"-get_and_update_in/3-fun-0-")(p0, p1, p2) do
    # body not decompiled
  end

  defp unquote(:"-get_and_update_in/3-fun-1-")(p0, p1, p2) do
    # body not decompiled
  end

  defp unquote(:"-get_in/2-fun-0-")(p0) do
    # body not decompiled
  end

  defp unquote(:"-get_in/2-fun-1-")(p0, p1) do
    # body not decompiled
  end

  defp unquote(:"-in_list/3-fun-0-")(p0, p1, p2) do
    # body not decompiled
  end

  defp unquote(:"-put_in/3-fun-0-")(p0, p1) do
    # body not decompiled
  end

  defp unquote(:"-struct!/2-fun-0-")(p0, p1) do
    # body not decompiled
  end

  defp unquote(:"-struct/2-fun-0-")(p0, p1) do
    # body not decompiled
  end

  defp unquote(:"-update_in/3-fun-0-")(p0, p1) do
    # body not decompiled
  end

  defp alias_meta(p0) do
    # body not decompiled
  end

  defp assert_module_scope(p0, p1, p2) do
    # body not decompiled
  end

  defp assert_no_function_scope(p0, p1, p2) do
    # body not decompiled
  end

  defp bootstrapped?(p0) do
    # body not decompiled
  end

  defp build_if(p0, p1) do
    # body not decompiled
  end

  defp build_unless(p0, p1) do
    # body not decompiled
  end

  defp comp(p0, p1) do
    # body not decompiled
  end

  defp decreasing_compare(p0, p1, p2) do
    # body not decompiled
  end

  defp define(p0, p1, p2, p3) do
    # body not decompiled
  end

  defp do_at(p0, p1, p2, p3, p4) do
    # body not decompiled
  end

  defp do_pop_in(p0, p1) do
    # body not decompiled
  end

  defp env_stacktrace(p0) do
    # body not decompiled
  end

  defp expand_aliases(p0, p1) do
    # body not decompiled
  end

  defp expand_module(p0, p1, p2) do
    # body not decompiled
  end

  defp extract_concatenations(p0) do
    # body not decompiled
  end

  defp in_list(p0, p1, p2) do
    # body not decompiled
  end

  defp in_range(p0, p1, p2) do
    # body not decompiled
  end

  defp in_range_literal(p0, p1, p2) do
    # body not decompiled
  end

  defp in_var(p0, p1, p2) do
    # body not decompiled
  end

  defp increasing_compare(p0, p1, p2) do
    # body not decompiled
  end

  defp module_nesting(p0, p1) do
    # body not decompiled
  end

  defp module_nesting(p0, p1, p2, p3) do
    # body not decompiled
  end

  defp module_vars(p0, p1) do
    # body not decompiled
  end

  defp nest_get_and_update_in(p0, p1) do
    # body not decompiled
  end

  defp nest_get_and_update_in(p0, p1, p2) do
    # body not decompiled
  end

  defp nest_pop_in(p0, p1) do
    # body not decompiled
  end

  defp nest_pop_in(p0, p1, p2) do
    # body not decompiled
  end

  defp nest_update_in(p0, p1) do
    # body not decompiled
  end

  defp nest_update_in(p0, p1, p2) do
    # body not decompiled
  end

  defp optimize_boolean(p0) do
    # body not decompiled
  end

  defp proper_start?(p0) do
    # body not decompiled
  end

  defp split_module(p0) do
    # body not decompiled
  end

  defp split_words(p0, p1) do
    # body not decompiled
  end

  defp struct(p0, p1, p2) do
    # body not decompiled
  end

  defp typespec(p0) do
    # body not decompiled
  end

  defp unnest(p0, p1, p2, p3) do
    # body not decompiled
  end

  defp wrap_binding(p0, p1) do
    # body not decompiled
  end

  defp wrap_concatenation(p0) do
    # body not decompiled
  end
end
